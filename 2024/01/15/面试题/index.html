<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题汇总 Vue | Axin</title><meta name="author" content="Axin"><meta name="copyright" content="Axin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="谈谈对 MVVM 的理解 MVVM 是 Model-View-ViewModel 的缩写，是一种设计思想。Model 代表数据模型；View 代表 UI 组件，在 MVVM 架构下，这两者之间没有直接的联系，而是通过 ViewModel 进行交互， Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题汇总 Vue">
<meta property="og:url" content="https://axin-link.github.io/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Axin">
<meta property="og:description" content="谈谈对 MVVM 的理解 MVVM 是 Model-View-ViewModel 的缩写，是一种设计思想。Model 代表数据模型；View 代表 UI 组件，在 MVVM 架构下，这两者之间没有直接的联系，而是通过 ViewModel 进行交互， Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-01-15T01:35:25.862Z">
<meta property="article:modified_time" content="2024-01-15T03:23:36.901Z">
<meta property="article:author" content="Axin">
<meta property="article:tag" content="个人、博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://axin-link.github.io/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题汇总 Vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-01-15 11:23:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Axin"><span class="site-name">Axin</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题汇总 Vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-01-15T01:35:25.862Z" title="Created 2024-01-15 09:35:25">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-15T03:23:36.901Z" title="Updated 2024-01-15 11:23:36">2024-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题汇总 Vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="谈谈对-MVVM-的理解"><a href="#谈谈对-MVVM-的理解" class="headerlink" title="谈谈对 MVVM 的理解"></a>谈谈对 MVVM 的理解</h1><blockquote>
<p>MVVM 是 Model-View-ViewModel 的缩写，是一种设计思想。Model 代表数据模型；View 代表 UI 组件，在 MVVM 架构下，这两者之间没有直接的联系，而是通过 ViewModel 进行交互， Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 对 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</blockquote>
<h1 id="Vue-的优点"><a href="#Vue-的优点" class="headerlink" title="Vue 的优点"></a>Vue 的优点</h1><blockquote>
<p>Vue是一个构建数据驱动的 Web 界面的渐进式框架。Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。关于 Vue 的优点主要有响应式编程、组件化开发、虚拟 DOM。</p>
<ul>
<li><p>响应式编程</p>
<p>通过 MVVM 思想实现数据的双向绑定，当应用数据发生变化时，视图自动更新，让开发者不用再操作 DOM 对象，有更多的时间去思考业务逻辑，这是通过一个响应式系统实现的，该系统基于 JavaScript 对象的 getter 和 setter。Vue2 和 Vue3 在响应式系统的实现上有所不同。（具体见 <strong>Vue的响应式原理</strong>）。</p>
</li>
<li><p>组件化开发</p>
<p>Vue 通过组件，把一个单页应用中的各种模块拆分到一个个单独的组件（component）中，我们只要现在父级组件中写好各种子组件，并在组件标签中写好传入子组件的参数，然后再分别写好各种子组件的实现。组件化开发可以提高开发效率、方便重复利用、简化调试步骤、提升整个项目的可维护性，便于协同开发。</p>
</li>
<li><p>虚拟 DOM</p>
<p>在传统开发中，用 JQuery 或者原生的 js 对 DOM 进行频繁操作的时候，浏览器要不停的渲染新的 DOM 树，导致在性能上的开销比较高。而虚拟 DOM 是通过状态生成一个虚拟节点树，在渲染页面之前会使用新生成的虚拟节点树与上一次生成的虚拟节点树进行对比（diff 算法），最后将 DOM 操作变化反映到真实 DOM 树上，只会渲染不同的部分。</p>
</li>
</ul>
</blockquote>
<h1 id="Vue-的响应式原理"><a href="#Vue-的响应式原理" class="headerlink" title="Vue 的响应式原理"></a>Vue 的响应式原理</h1><blockquote>
<ol>
<li><p>数据劫持：</p>
<p>在 Vue2 中，通过 <code>Object.defineProperty</code> 方法对组件的 <code>data</code> 对象的每个属性进行处理，将它们转换为 getter&#x2F;setter。Vue3 中则使用 ES6 的 <code>Proxy</code> 对象，允许它拦截并定义对象的基本操作，如属性读取、写入等。</p>
</li>
<li><p>依赖收集：</p>
<p>当模板或计算属性等访问某个响应式数据时，这个数据的 getter 函数就会执行。在 getter 函数执行的过程中，Vue 会识别当前正在评估的组件，并将其添加到该数据项的依赖列表中。这个组件成为该数据的一个依赖。</p>
</li>
<li><p>派发更新：</p>
<p>当响应式数据发生变化时（通过 setter），Vue 会通知所有依赖于这个数据的组件。然后，这些组件将重新渲染或执行其他必要的操作来反映新的数据状态。</p>
</li>
<li><p>虚拟 DOM 重新渲染：</p>
<p>Vue 使用虚拟 DOM 来减少直接操作真实 DOM 的次数，因为这通常是非常耗费性能的。当数据变化导致视图需要更新时，Vue 会先生成一个新的虚拟 DOM 树。然后，Vue 会比较新旧虚拟 DOM 树的差异，并计算出需要在真实 DOM 上进行的最小变更集。最后，Vue 会批量应用这些变更到真实 DOM 上，从而更新视图。</p>
<p>在 Vue 2.x 中，这个响应式系统依赖于 <code>Object.defineProperty</code> 在 Vue 3.x 中，Vue 引入了一个新的响应式系统，它使用了 ES6 的 <code>Proxy</code> 特性来替代 <code>Object.defineProperty</code>，这带来了更好的性能和更多的功能，例如直接监视数组的变化和更好的处理嵌套对象。</p>
</li>
</ol>
</blockquote>
<h1 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h1><blockquote>
<p>对于 Vue 来说，生命周期就是一个 Vue 实例从创建到销毁的过程。</p>
<p>总共分为 8 个阶段：创建前后，挂载前后，更新前后，销毁前后</p>
<ol>
<li><p>beforeCreate：是 new Vue() 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p>
</li>
<li><p>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，当前阶段无法与 DOM 进行交互，如果一定要交互的话，可以使用 <code>vm.$nextTick</code> 来访问 DOM</p>
</li>
<li><p>beforeMount：发生在挂载之前，在这之前 template 模板已经导入渲染函数编译。而当前阶段虚拟 DOM 已经创建完成，即将开始渲染，在这个阶段也可以对数据进行更改，但是不会触发 updated</p>
</li>
<li><p>mounted：在挂载完成后发生，在当前阶段，真实的 DOM 已经挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 <code>$refs</code> 属性对 DOM 进行操作</p>
</li>
<li><p>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟 DOM 重新渲染之前触发，可以在这个阶段进行更改数据，但不会造成重渲染</p>
</li>
<li><p>updated：发生在更新完成之后，当前阶段 DOM 已经完成更新。要注意的是避免在这个阶段更改数据，因为可能会导致无限循环的更新</p>
</li>
<li><p>beforeDestroy：发生在实例销毁之前，在当前阶段实例还可以被使用，可以在此阶段进行一些善后收尾操作，比如清除计时器</p>
</li>
<li><p>destroyed：发生在实例销毁之后，此阶段只剩下了 DOM 空壳，组件已经被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁</p>
</li>
</ol>
<p>第一次加载页面会触发 4 个钩子，分别是：beforeCreate、created、beforeMount、mounted</p>
<ul>
<li><p>多组件（父子组件）中生命周期的调用顺序</p>
<p>​	组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父</p>
<ul>
<li>加载渲染过程：父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</li>
<li>子组件更新过程：父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
<li>父组件更新过程：父 beforeUpdate -&gt; 父 updated</li>
<li>销毁过程：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Vue-的单向数据流和双向数据绑定"><a href="#Vue-的单向数据流和双向数据绑定" class="headerlink" title="Vue 的单向数据流和双向数据绑定"></a>Vue 的单向数据流和双向数据绑定</h1><blockquote>
<p><strong>单向数据流</strong>是一种在现代前端框架中常见的数据管理模式，它强调数据应该有一个明确的来源和方向，从而使得应用的状态更易于理解和调试。Vue.js 也遵循这种模式，尽管它支持双向数据绑定。下面是单向数据流在 Vue 中的一些关键概念和实践：</p>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ol>
<li><strong>数据的单一来源</strong>: 这意味着每个数据项应该只有一个地方定义它。在 Vue 应用中，这通常是在组件的 <code>data</code> 选项或 Vuex 存储中。</li>
<li><strong>数据自上而下流动</strong>: 数据从父组件流向子组件，这通常是通过 props 实现的。当父组件的状态发生变化时，这些变化会通过 props 传递给子组件，但子组件不能直接修改这些接收到的 props。</li>
<li><strong>事件自下而上流动</strong>: 当子组件需要修改由父组件传递下来的数据时，它应该通过发出事件（而不是直接修改数据）来通知父组件。然后，父组件可以处理这个事件并相应地更新数据。</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>可预测性</strong>: 由于数据总是按照相同的方式流动，应用的状态变得更加可预测和易于理解。</li>
<li><strong>易于调试</strong>: 发现和修复数据相关的问题更容易，因为数据流是线性的且方向明确。</li>
<li><strong>避免数据污染</strong>: 子组件不能直接修改父组件的状态，这有助于防止意外的副作用和数据污染。</li>
</ul>
<p>单向数据流在构建大型和复杂的应用时特别有用，因为它可以帮助维持数据的一致性和可管理性。</p>
<p><strong>双向数据绑定</strong>是 Vue 的一个特性，它主要通过 <code>v-model</code> 指令在表单元素（如 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code>）上实现。<code>v-model</code> 实质上是一个语法糖，它结合了：</p>
<ul>
<li>数据到视图的绑定（类似于 <code>v-bind:value</code>）。</li>
<li>视图到数据的绑定（通过监听 <code>input</code> 事件并更新数据）。</li>
</ul>
<p>当你使用 <code>v-model</code> 时，Vue 内部实际上为你处理了数据的监听（使用响应式系统）和视图的更新（监听元素的输入事件并更新数据）。</p>
<h3 id="和响应式系统的关联和区别"><a href="#和响应式系统的关联和区别" class="headerlink" title="和响应式系统的关联和区别"></a>和响应式系统的关联和区别</h3><ul>
<li><strong>关联</strong>：双向数据绑定依赖于 Vue 的响应式系统。响应式系统确保当数据变化时视图能够更新，而双向数据绑定则同时处理视图到数据的更新。</li>
<li><strong>区别</strong>：响应式系统关注于如何追踪数据变化并响应这些变化，而双向数据绑定则是一个更高级的概念，它不仅包括响应式系统的数据更新，还包括从视图到数据的更新（例如，用户在表单元素中的输入）。</li>
</ul>
<p>总结来说，Vue 的双向数据绑定是建立在响应式系统之上的一个特性，专门用于表单元素的数据同步，而响应式系统是 Vue 更广泛的一个特性，用于追踪和响应任何可观测数据的变化。</p>
</blockquote>
<h1 id="Vue-中的组件传参"><a href="#Vue-中的组件传参" class="headerlink" title="Vue 中的组件传参"></a>Vue 中的组件传参</h1><blockquote>
<p><strong>使用 Props 传递</strong></p>
<p><code>props</code> 是父组件向子组件传递数据的主要方式。子组件通过定义 <code>props</code> 选项来接收来自父组件的数据</p>
<ol>
<li><p>在子组件中定义 Props</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;message&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件通过自定义属性向子组件传递数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComponent :message=&quot;parentMessage&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      parentMessage: &#x27;Hello from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>使用 Events 进行通讯</strong></p>
<ol>
<li><p>子组件使用 <code>$emit</code> 方法触发事件，并将数据作为参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendMessageToParent&quot;&gt;Send Message&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMessageToParent() &#123;</span><br><span class="line">      this.$emit(&#x27;messageChanged&#x27;, &#x27;New message from child&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件监听子组件触发的事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComponent @messageChanged=&quot;handleMessage&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage(newMessage) &#123;</span><br><span class="line">      console.log(&#x27;Received message:&#x27;, newMessage);</span><br><span class="line">      // 处理接收到的数据</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Provide&#x2F;Inject（依赖注入）</strong></p>
<p>Vue 提供了 <code>provide</code> 和 <code>inject</code> API，允许祖组件提供数据，任何子孙组件都可以注入这些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 祖组件 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: this.data</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: &#x27;some data&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">// 不需要任何代码</span><br><span class="line"></span><br><span class="line">&lt;!-- 孙组件 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#x27;data&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用所有组件的状态，并以响应的规则保证状态以一种可预测的方式发生变化，Vuex 非常适合处理多个组件共享状态的情况，尤其是在大型应用中，可以大大简化组件间状态传递和管理</p>
<p><strong>Vuex 核心概念</strong></p>
<ul>
<li>State：标识应用的状态，在 Vuex 中，state 是单一状态树，即所有组件的状态都被集中到一个对象中</li>
<li>Getters：类似于计算属性，允许从 state 中派生出一些状态，以便于组件使用</li>
<li>Mutations：唯一更改 state 的方法，必须是同步函数</li>
<li>Actions：类似于 mutations，但是负责提交的是 mutation，而不是直接变更状态，可以包含任意异步操作</li>
<li>Modules：Vuex 允许将 store 分割成模块，每个模块都有自己的 state、getters、mutations 和 actions</li>
</ul>
</blockquote>
<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><blockquote>
<p>Pinia 是 Vue 生态系统中的一个新的状态管理库，被设计为 Vuex 的替代品，特别是针对 Vue3。它提供了一个更加简洁和易于理解的 API，同时保持了响应式和模块化的状态管理能力。</p>
<p><strong>Pinia 的主要特点</strong></p>
<ul>
<li>简洁的 API：pinia 提供了一个更简洁、更直观的 API，与 Vuex 相比更为简洁和直接</li>
<li>完全的 TypeScript 支持：pinia 兼容 TypeScript，为 TypeScript 用户提供了很好的体验</li>
<li>模块化的状态管理：pinia 允许将状态分割成多个独立的 store，使得状态管理更加模块化和可维护</li>
<li>开箱即用的 SSR 支持：对于服务器端渲染（SSR），pinia 提供了开箱即用的支持</li>
<li>更好的开发体验：pinia 支持 Vue DevTools，提供了丰富的调试功能</li>
</ul>
</blockquote>
<h1 id="计算属性和侦听器的区别"><a href="#计算属性和侦听器的区别" class="headerlink" title="计算属性和侦听器的区别"></a>计算属性和侦听器的区别</h1><blockquote>
<p>这两者都是 Vue 中处理响应式数据的方法，它们都可以用来基于响应式数据执行逻辑，但是各自的使用场景和工作方式有所不同</p>
<p><strong>计算属性</strong></p>
<p>计算属性是基于它们的依赖进行缓存的响应式属性，主要用于当一个数据依赖于其他数据变化时自动更新</p>
<ul>
<li>定义方式：作为 Vue 实例的 <code>computed</code> 选项的一部分定义</li>
<li>缓存性：只有当依赖的响应式属性发生变化时才会重新计算</li>
<li>主要用途：当需要根据现有的响应式数据计算出新的值时，例如：根据购物车内的商品计算总价</li>
</ul>
<p><strong>侦听器</strong></p>
<p>侦听器允许执行代码响应数据的变化，但是不会像计算属性那样返回一个值，它们更适合执行异步操作或者昂贵的操作</p>
<ul>
<li>定义方式：作为 Vue 实例的 <code>watch</code> 选项的一部分定义</li>
<li>反应性：每次被侦听的数据发生变化时，都会执行回调函数</li>
<li>主要用途：响应数据的变化执行异步操作或者开销较大的操作，例如：基于用户输入的地址信息获取地理位置</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>返回值：计算属性基于依赖数据计算得出的值，而侦听器不返回值，而是执行代码</li>
<li>缓存：计算属性具有缓存，仅在依赖项改变时重新计算，侦听器每次触发都会执行</li>
<li>用途：计算属性适用于计算值，侦听器适用于观察和响应 Vue 实例上数据的变化</li>
</ul>
<p>在选择使用计算属性还是侦听器时，考虑你的需求是否需要计算出新的值，或者只是需要在数据变化时执行某些操作。通常，计算属性用于简单的同步操作，而侦听器更适合处理数据变化的复杂逻辑，包括异步操作。</p>
</blockquote>
<h1 id="Vue-中-ref-和-reactive-的区别"><a href="#Vue-中-ref-和-reactive-的区别" class="headerlink" title="Vue 中 ref 和 reactive 的区别"></a>Vue 中 ref 和 reactive 的区别</h1><blockquote>
<p>在Vue中，<code>ref</code> 和 <code>reactive</code> 是用于创建响应式数据的两种不同方法。它们都是 Vue3 的 Composition   API 的一部分，但有一些关键的区别：</p>
<ol>
<li>定义方式：<ul>
<li><code>ref</code> 用于定义一个响应式的引用类型，当想让任何类型的变量（包括基本类型如字符串、数字等）变得响应式时使用。它返回一个包含 <code>.value</code> 属性的对象</li>
<li><code>reactive</code> 则是用于创建一个响应式的对象。它是用于复杂的数据结构，如对象或数组。</li>
</ul>
</li>
<li>用法：<ul>
<li>使用 <code>ref</code> 时，你需要通过 <code>.value</code> 属性来访问或修改它的值。这是因为 <code>ref</code> 实际上创建了一个包含值的容器对象。</li>
<li>使用 <code>reactive</code> 时，你可以直接访问和修改对象的属性，无需使用 <code>.value</code>。这是因为  <code> reactive</code> 直接在原始对象上创建了一个响应式的代理。</li>
</ul>
</li>
<li>应用场景：<ul>
<li><code>ref</code> 通常用于基本类型数据，但也可以用于引用类型数据。当你需要在模板中直接绑定一个基本类型值或需要跨组件传递一个响应式值时，<code>ref</code> 非常有用。</li>
<li><code>reactive</code> 适用于更复杂的数据结构，如对象或数组。当你有一个对象或数组，并且你想让它的所有嵌套属性都是响应式的，那么 <code>reactive</code> 是更好的选择。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="data-为什么是一个函数"><a href="#data-为什么是一个函数" class="headerlink" title="data 为什么是一个函数"></a>data 为什么是一个函数</h1><blockquote>
<ol>
<li><strong>实例隔离</strong>：当组件被多次使用时（比如在<code>v-for</code>循环中或者作为多个页面的一部分），每个实例都应该维护一套独立的数据。如果<code>data</code>是一个对象，则所有实例将共享相同的数据对象，这会导致一个实例的状态更改会影响到其他所有实例。使用函数返回一个新的数据对象可以确保每个组件实例都有自己的独立数据副本。</li>
<li><strong>数据初始化</strong>：当组件每次创建时，<code>data</code>函数都会被调用。这样可以为每个组件实例提供全新的数据对象，保证了组件的数据是干净、未被修改的。如果<code>data</code>是一个对象，则所有组件实例将共享同一个初始数据对象，任何对这个对象的修改都会反映在所有组件实例上。</li>
<li><strong>灵活性</strong>：<code>data</code>作为一个函数，可以在函数体内执行一些计算或逻辑操作，以决定返回什么样的初始数据。这提供了更多的灵活性，比如基于props的值来初始化数据。</li>
</ol>
</blockquote>
<h1 id="Vue-中的路由守卫"><a href="#Vue-中的路由守卫" class="headerlink" title="Vue 中的路由守卫"></a>Vue 中的路由守卫</h1><blockquote>
<p>在Vue中，路由守卫（Route Guards）是一种非常有用的功能，它允许你在路由发生变化时进行检查或执行操作，如验证用户权限、记录日志、保存表单状态或者改变界面状态。路由守卫提供了强大的方法来控制和管理路由跳转，确保应用的导航行为符合预期，同时提升了用户体验和应用安全性。Vue Router 提供了多种方式来设置路由守卫，包括全局守卫、路由独享的守卫和组件内的守卫。</p>
<h3 id="1-全局守卫："><a href="#1-全局守卫：" class="headerlink" title="1. 全局守卫："></a>1. 全局守卫：</h3><p>这些守卫会在任何路由跳转发生时被触发。</p>
<ul>
<li><strong>全局前置守卫 (<code>beforeEach</code>)</strong>: 在路由跳转之前被调用。（进行权限检查，登录重定向等）</li>
<li><strong>全局解析守卫 (<code>beforeResolve</code>)</strong>: 在路由被确认之前，同时在所有组件内守卫和异步路由组件被解析之后调用。</li>
<li><strong>全局后置钩子 (<code>afterEach</code>)</strong>: 在路由跳转后被调用，没有<code>next</code>函数，不能改变导航。</li>
</ul>
<h3 id="2-路由独享的守卫："><a href="#2-路由独享的守卫：" class="headerlink" title="2. 路由独享的守卫："></a>2. 路由独享的守卫：</h3><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫。</p>
<h3 id="3-组件内的守卫："><a href="#3-组件内的守卫：" class="headerlink" title="3. 组件内的守卫："></a>3. 组件内的守卫：</h3><p>在路由组件内部，你可以定义一些守卫。</p>
<ul>
<li><strong><code>beforeRouteEnter</code></strong>: 在渲染该组件的对应路由被 confirm 前调用。</li>
<li><strong><code>beforeRouteUpdate</code></strong> (2.2+): 在当前路由改变，但是该组件被复用时调用。</li>
<li><strong><code>beforeRouteLeave</code></strong>: 导航离开该组件的对应路由时调用。</li>
</ul>
</blockquote>
<h1 id="单页面应用的优缺点"><a href="#单页面应用的优缺点" class="headerlink" title="单页面应用的优缺点"></a>单页面应用的优缺点</h1><blockquote>
<p>单页面应用（SPA，Single Page Application）是一种Web应用程序或网站的设计模式，其中只有一个主要的Web页面，但可以提供像传统多页面网站那样的用户体验。SPA通过JavaScript动态重写当前页面的内容来与用户互动，而不是传统的从服务器加载整个新页面。下面是SPA的主要优缺点：</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>用户体验</strong>: 提供更流畅和快速的用户体验。由于页面不需要在用户操作时完全重新加载，用户感觉到的延迟更少。</li>
<li><strong>前后端分离</strong>: 使得前端和后端开发可以独立进行，通常通过API进行交互。这有助于分工协作和维护。</li>
<li><strong>减少服务器负载</strong>: SPA减少了对服务器的请求次数，因为大部分资源（HTML、CSS、Scripts）只需在应用开始时加载一次。</li>
<li><strong>良好的跨平台兼容性</strong>: 可以轻松地被封装成移动应用或桌面应用。</li>
<li><strong>更容易的缓存处理</strong>: 只需加载一次数据，然后可以通过前端存储来使用，无需每次都从服务器重新加载。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>SEO优化困难</strong>: 由于内容是动态加载的，搜索引擎可能难以索引SPA的内容，虽然现代技术（如服务器端渲染）有所改善。</li>
<li><strong>初始加载时间长</strong>: 第一次加载时需要加载整个应用的资源，可能导致初始加载时间长于传统多页面应用。</li>
<li><strong>JavaScript依赖性</strong>: 如果用户禁用了JavaScript，SPA将无法正常工作。</li>
<li><strong>浏览器历史和导航</strong>: SPA可能需要额外的逻辑来正确处理浏览器的后退和前进按钮。</li>
<li><strong>内存泄漏风险</strong>: 不当的内存管理可能导致长时间运行的SPA出现性能问题。</li>
<li><strong>安全风险</strong>: 由于大量的前端代码，SPA可能面临诸如跨站脚本（XSS）等安全威胁。</li>
</ol>
<p>总体来说，SPA适合那些需要提供丰富交互和更快响应的应用，但它们也需要开发者在SEO、性能优化和安全性方面投入更多的努力。	</p>
<p>在Vue.js中实现的单页面应用（SPA）继承了传统SPA的一般优缺点，并结合了Vue的特定特性。下面是在Vue.js环境中单页面应用的一些优缺点：</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>响应式和组件化</strong>: Vue的响应式系统和组件化模型为SPA提供了高效的更新和渲染方式。这使得应用更加快速和动态。</li>
<li><strong>易于状态管理</strong>: 通过使用Vuex，Vue应用可以更方便地管理全局状态，这对于构建大型单页应用尤其重要。</li>
<li><strong>工具生态丰富</strong>: Vue提供了一整套工具和库（如Vue Router, Vuex等），这些工具都是为了构建和维护SPA而设计的。</li>
<li><strong>灵活性和可维护性</strong>: Vue的灵活性允许开发者按需求选择或替换工具和库，同时保持了代码的可维护性。</li>
<li><strong>易于集成和迁移</strong>: Vue的轻量和模块化特性使得它容易集成到现有项目中，或逐步迁移旧项目到Vue。</li>
<li><strong>服务器端渲染支持</strong>: Vue提供了服务器端渲染（SSR）支持，这可以改善SPA的SEO表现和首屏加载时间。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>SEO挑战</strong>: 虽然Vue支持SSR，但构建和维护SSR应用比传统SPA更复杂，且需要更多的服务器资源。</li>
<li><strong>初始加载性能</strong>: 由于需要加载整个应用框架和相关资源，SPA可能会有较长的首次加载时间。</li>
<li><strong>JavaScript依赖性</strong>: 如果用户的浏览器不支持JavaScript或者JavaScript被禁用，那么Vue SPA可能无法正常工作。</li>
<li><strong>安全考虑</strong>: SPA可能会面临跨站脚本（XSS）等安全威胁，需要在开发中特别注意。</li>
<li><strong>复杂状态管理</strong>: 对于大型应用，状态管理可能变得复杂，需要谨慎地使用Vuex等工具来维护状态。</li>
<li><strong>浏览器历史管理</strong>: Vue Router虽然提供了路由功能，但对于浏览器历史的管理仍需精心设计，以提供直观的用户导航体验。</li>
</ol>
<p>总而言之，在Vue中构建SPA能够带来丰富的用户体验和高效的前端性能，但同时也需要在SEO、初始加载性能和安全方面进行一定的优化和权衡。</p>
</blockquote>
<h1 id="v-if-和-v-for-可以一起使用吗"><a href="#v-if-和-v-for-可以一起使用吗" class="headerlink" title="v-if 和 v-for 可以一起使用吗"></a>v-if 和 v-for 可以一起使用吗</h1><blockquote>
<p>在Vue中，虽然技术上可以同时在一个元素上使用<code>v-if</code>和<code>v-for</code>，但这通常不推荐这样做，原因如下：</p>
<ol>
<li><strong>性能考虑</strong>: 当<code>v-if</code>和<code>v-for</code>一起使用时，对于每个循环的项，<code>v-if</code>都会被评估一次。这意味着如果有大量数据项，将会执行大量的条件判断，这可能导致性能问题。</li>
<li><strong>可读性和维护性</strong>: 同时使用<code>v-if</code>和<code>v-for</code>会使代码的逻辑变得更复杂，从而降低代码的可读性和维护性。</li>
<li><strong>优先级问题</strong>: <code>v-for</code>比<code>v-if</code>具有更高的优先级。这意味着<code>v-if</code>将在每次循环迭代中运行，而不是在整个列表上条件渲染。</li>
</ol>
</blockquote>
<h1 id="Vue-中的插槽"><a href="#Vue-中的插槽" class="headerlink" title="Vue 中的插槽"></a>Vue 中的插槽</h1><blockquote>
<p>在Vue.js中，插槽（Slots）是一种重要的组件通信机制，它允许你从父组件向子组件插入内容，而子组件可以决定这些内容在其模板中的放置位置。这提供了一种灵活的方式来创建可复用的组件，同时保持了模板的清晰和可维护性。</p>
<p><strong>基本用法</strong></p>
<ol>
<li><strong>默认插槽</strong>: 在子组件中，你可以定义一个 <code>&lt;slot&gt;</code> 元素来指定内容插入的位置。如果父组件提供了内容，它将替换掉 <code>&lt;slot&gt;</code> 元素。</li>
<li><strong>具名插槽</strong>: 你可以通过给 <code>&lt;slot&gt;</code> 元素一个名字来创建多个插槽。父组件可以通过 <code>slot</code> 属性指定内容应插入到哪个插槽中。</li>
<li><strong>作用域插槽</strong>: 作用域插槽允许子组件传递数据回父组件的插槽内容中。这对于创建高度可定制的组件特别有用。</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li>插槽内容是在父组件作用域内编译的，不是在子组件。</li>
<li>使用插槽时，子组件不能直接访问父组件插入的内容，它只是指定内容插入的位置。</li>
<li>作用域插槽允许子组件向父组件提供数据，这在创建可复用和可配置的组件时非常有用。</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Axin-link.github.io">Axin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://axin-link.github.io/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98/">https://axin-link.github.io/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB-js/" title="面试题汇总 js"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">面试题汇总 js</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Axin</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Axin-link"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Axin-link" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3498018835@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-MVVM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">谈谈对 MVVM 的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Vue 的优点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Vue 的响应式原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">Vue 的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">5.</span> <span class="toc-text">Vue 的单向数据流和双向数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.1.</span> <span class="toc-text">关键概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">5.0.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E8%81%94%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.3.</span> <span class="toc-text">和响应式系统的关联和区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="toc-number">6.</span> <span class="toc-text">Vue 中的组件传参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex"><span class="toc-number">7.</span> <span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pinia"><span class="toc-number">8.</span> <span class="toc-text">Pinia</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">计算属性和侦听器的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E4%B8%AD-ref-%E5%92%8C-reactive-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">Vue 中 ref 和 reactive 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">data 为什么是一个函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-number">12.</span> <span class="toc-text">Vue 中的路由守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB%EF%BC%9A"><span class="toc-number">12.0.1.</span> <span class="toc-text">1. 全局守卫：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB%EF%BC%9A"><span class="toc-number">12.0.2.</span> <span class="toc-text">2. 路由独享的守卫：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB%EF%BC%9A"><span class="toc-number">12.0.3.</span> <span class="toc-text">3. 组件内的守卫：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">单页面应用的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">13.0.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">13.0.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">13.0.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">13.0.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-if-%E5%92%8C-v-for-%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97"><span class="toc-number">14.</span> <span class="toc-text">v-if 和 v-for 可以一起使用吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD"><span class="toc-number">15.</span> <span class="toc-text">Vue 中的插槽</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB-js/" title="面试题汇总 js">面试题汇总 js</a><time datetime="2024-01-15T08:17:47.000Z" title="Created 2024-01-15 16:17:47">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题汇总 Vue">面试题汇总 Vue</a><time datetime="2024-01-15T01:35:25.862Z" title="Created 2024-01-15 09:35:25">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Axin</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>